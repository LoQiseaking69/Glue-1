use std::iter::Peekable;
use std::slice::Iter;

// Assuming the Token and TokenType structs from the Lexer script are available

#[derive(Debug)]
enum ASTNode {
    Number(f64),
    BinaryOp(Box<ASTNode>, Operator, Box<ASTNode>),
    // More nodes for complex structures in GLUE and algebraic operations
}

enum Operator {
    Add,
    Subtract,
    Multiply,
    Divide,
    // Additional operators for Hehner's Algebra
}

fn parse(tokens: &[Token]) -> Result<ASTNode, String> {
    let mut iter = tokens.iter().peekable();
    parse_expression(&mut iter)
}

fn parse_expression(iter: &mut Peekable<Iter<Token>>) -> Result<ASTNode, String> {
    let mut node = parse_term(iter)?;

    while let Some(&&Token { token_type: TokenType::Operator, value: ref op }) = iter.peek() {
        match op.as_str() {
            "+" | "-" => {
                iter.next(); // consume operator
                let right = parse_term(iter)?;
                node = ASTNode::BinaryOp(Box::new(node), map_operator(op)?, Box::new(right));
            }
            _ => break,
        }
    }

    Ok(node)
}

fn parse_term(iter: &mut Peekable<Iter<Token>>) -> Result<ASTNode, String> {
    let mut node = parse_factor(iter)?;

    while let Some(&&Token { token_type: TokenType::Operator, value: ref op }) = iter.peek() {
        match op.as_str() {
            "*" | "/" => {
                iter.next(); // consume operator
                let right = parse_factor(iter)?;
                node = ASTNode::BinaryOp(Box::new(node), map_operator(op)?, Box::new(right));
            }
            _ => break,
        }
    }

    Ok(node)
}

fn parse_factor(iter: &mut Peekable<Iter<Token>>) -> Result<ASTNode, String> {
    if let Some(token) = iter.next() {
        match token.token_type {
            TokenType::Number => Ok(ASTNode::Number(token.value.parse().unwrap())),
            TokenType::Parenthesis if token.value == "(" => {
                let node = parse_expression(iter)?;
                if iter.next().map_or(false, |token| token.value == ")") {
                    Ok(node)
                } else {
                    Err("Missing closing parenthesis".to_string())
                }
            }
            // Additional parsing rules for GLUE-specific syntax and algebraic expressions
            _ => Err("Unexpected token".to_string()),
        }
    } else {
        Err("Unexpected end of input".to_string())
    }
}

fn map_operator(op: &str) -> Result<Operator, String> {
    match op {
        "+" => Ok(Operator::Add),
        "-" => Ok(Operator::Subtract),
        "*" => Ok(Operator::Multiply),
        "/" => Ok(Operator::Divide),
        // Additional mapping for GLUE-specific operators
        _ => Err(format!("Unknown operator: {}", op)),
    }
}

fn main() {
    // Example for testing the parser
    let tokens = vec![
        // Tokens generated by the Lexer (example)
    ];

    match parse(&tokens) {
        Ok(ast) => println!("{:?}", ast),
        Err(e) => eprintln!("Parser error: {}", e),
    }
}